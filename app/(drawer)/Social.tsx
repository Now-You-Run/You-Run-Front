import { getUserById } from '@/api/user';
import { Ionicons } from '@expo/vector-icons';
import { useNavigation } from '@react-navigation/native';
import * as Notifications from 'expo-notifications';
import { useRouter } from 'expo-router';
import React, { useEffect, useRef, useState } from 'react';
import {
  ActivityIndicator,
  Alert,
  Image,
  ScrollView,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from 'react-native';

// STOMP ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏûÑÌè¨Ìä∏
import { Client, IMessage } from '@stomp/stompjs';

interface FriendRequest {
  id: number | string;
  friendId: number | string;
  name?: string;
}

interface Friend {
  id: string;
  friend_id: string;
  name: string;
  image: any;
  level?: number | null;
  grade?: string | null;
  status?: string | null;
}

const SERVER_API_URL = process.env.EXPO_PUBLIC_SERVER_API_URL;
const MY_USER_ID = 1;
const DEFAULT_AVATAR = require('../../assets/profile/Ïú†Ï†Ä_Í∏∞Î≥∏_ÌîÑÎ°úÌïÑ.jpeg');

export default function Social() {
  const [myUserName, setMyUserName] = useState<string>('');
  const router = useRouter();
  const navigation = useNavigation();
  const pendingRef = useRef<number>(0);
  const [isEditing, setIsEditing] = useState(false);
  const [friends, setFriends] = useState<Friend[]>([]);
  const [loading, setLoading] = useState(true);
  const [pendingRequests, setPendingRequests] = useState<number>(0);
  const [friendRequests, setFriendRequests] = useState<FriendRequest[]>([]);
  const [showRequests, setShowRequests] = useState(false);
  const [disabledFriendTimestamps, setDisabledFriendTimestamps] = useState<
    Map<string, number>
  >(new Map());
  const [friendPointHistories, setFriendPointHistories] = useState<
    Map<string, number>
  >(new Map());

  const stompClientRef = useRef<Client | null>(null);

  const getWsUrl = (baseUrl: string | undefined): string | undefined => {
    if (!baseUrl) return undefined;

    let protocol: string;
    let cleanBaseUrl: string;

    // HTTPS -> WSS, HTTP -> WS Î°ú Î≥ÄÍ≤Ω
    if (baseUrl.startsWith('https://')) {
      protocol = 'wss://'; // Î≥¥Ïïà ÏõπÏÜåÏºì ÌîÑÎ°úÌÜ†ÏΩú
      cleanBaseUrl = baseUrl.substring(8); // 'https://' Ï†úÍ±∞
    } else if (baseUrl.startsWith('http://')) {
      protocol = 'ws://'; // ÏùºÎ∞ò ÏõπÏÜåÏºì ÌîÑÎ°úÌÜ†ÏΩú
      cleanBaseUrl = baseUrl.substring(7); // 'http://' Ï†úÍ±∞
    } else {
      // ÌîÑÎ°úÌÜ†ÏΩúÏù¥ ÏóÜÎäî Í≤ΩÏö∞ (Ïòà: localhost:3000)
      console.warn('SERVER_API_URLÏóê Ïú†Ìö®Ìïú ÌîÑÎ°úÌÜ†ÏΩúÏù¥ ÏóÜÏäµÎãàÎã§:', baseUrl);
      protocol = 'ws://';
      cleanBaseUrl = baseUrl;
    }

    // cleanBaseUrlÏóêÏÑú Ïû†Ïû¨Ï†ÅÏù∏ ÎÅù Ïä¨ÎûòÏãú Ï†úÍ±∞
    if (cleanBaseUrl.endsWith('/')) {
      cleanBaseUrl = cleanBaseUrl.slice(0, -1);
    }

    return `${protocol}${cleanBaseUrl}/ws`;
  };

  // ÏπúÍµ¨ ÏöîÏ≤≠ ÏÜåÏºì (STOMP ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Î°ú Î≥ÄÍ≤Ω)
  useEffect(() => {
    fetchPendingRequestCount();
    fetchFriendRequests();
    fetchFriends();

    const wsUrl = getWsUrl(SERVER_API_URL);

    if (wsUrl) {
      const stompClient = new Client({
        webSocketFactory: () => new WebSocket(wsUrl),

        reconnectDelay: 5000,
        heartbeatIncoming: 4000,
        heartbeatOutgoing: 4000,

        onConnect: () => {
          console.log('‚úÖ STOMP WebSocket Ïó∞Í≤∞ ÏÑ±Í≥µ');

          stompClient.subscribe(
            `/topic/friend-requests/${MY_USER_ID}`,
            (message: IMessage) => {
              console.log('üì® STOMP Î©îÏãúÏßÄ ÏàòÏã†:', message.body);
              try {
                const notification = JSON.parse(message.body);
                if (notification.pendingCount !== undefined) {
                  if (notification.pendingCount > pendingRef.current) {
                    fetchFriendRequests();
                    Alert.alert('ÏÉà ÏπúÍµ¨ ÏöîÏ≤≠', `ÏÉà ÏπúÍµ¨ ÏöîÏ≤≠Ïù¥ ÎèÑÏ∞©ÌñàÏäµÎãàÎã§.`);
                  }
                  setPendingRequests(notification.pendingCount);
                  pendingRef.current = notification.pendingCount;
                }
              } catch (error) {
                console.error('Î©îÏãúÏßÄ ÌååÏã± Ïò§Î•ò', error);
              }
            }
          );
        },

        onStompError: (frame) => {
          console.error('‚ùå STOMP ÏóêÎü¨:', frame.headers['message'], frame.body);
          Alert.alert(
            'STOMP Ïò§Î•ò',
            `STOMP Ïó∞Í≤∞ Ï§ë Ïò§Î•ò Î∞úÏÉù: ${frame.headers['message']}`
          );
        },

        // onWebSocketError: (event) => {
        //   console.error('‚ùå Low-level WebSocket ÏóêÎü¨:', event);
        // },

        onDisconnect: () => {
          console.log('üõë STOMP WebSocket Ïó∞Í≤∞ Ï¢ÖÎ£å');
        },
      });

      stompClient.activate();
      stompClientRef.current = stompClient;

      return () => {
        if (stompClientRef.current && stompClientRef.current.active) {
          stompClientRef.current.deactivate();
        }
      };
    } else {
      console.error(
        'WebSocket URLÏùÑ ÏÉùÏÑ±Ìï† Ïàò ÏóÜÏäµÎãàÎã§. SERVER_API_URLÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî.'
      );
    }
  }, []);

  // Ìë∏Ïãú ÌÜ†ÌÅ∞
  useEffect(() => {
    const registerPushToken = async () => {
      try {
        const { status } = await Notifications.getPermissionsAsync();
        let finalStatus = status;
        if (status !== 'granted') {
          const { status: askStatus } =
            await Notifications.requestPermissionsAsync();
          finalStatus = askStatus;
        }
        if (finalStatus !== 'granted') {
          Alert.alert(
            'ÏïåÎ¶º Í∂åÌïú ÌïÑÏöî',
            'ÏïåÎ¶º Í∂åÌïúÏùÑ ÌóàÏö©Ìï¥Ïïº Ìë∏Ïãú ÏïåÎ¶ºÏùÑ Î∞õÏùÑ Ïàò ÏûàÏäµÎãàÎã§.'
          );
          return;
        }

        const tokenData = await Notifications.getExpoPushTokenAsync();
        const pushToken = tokenData.data;
        console.log('Î∞õÏùÄ Ìë∏Ïãú ÌÜ†ÌÅ∞:', pushToken);

        const response = await fetch(
          `${SERVER_API_URL}/api/push-token/register`,
          {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ userId: MY_USER_ID, pushToken }),
          }
        );

        const json = await response.json();
        if (!response.ok) {
          console.error('Ìë∏Ïãú ÌÜ†ÌÅ∞ Îì±Î°ù Ïã§Ìå®:', json);
          Alert.alert('Ìë∏Ïãú ÌÜ†ÌÅ∞ Îì±Î°ù Ïã§Ìå®', json.message ?? 'Ïïå Ïàò ÏóÜÎäî Ïò§Î•ò');
          return;
        }

        console.log('‚úÖ Ìë∏Ïãú ÌÜ†ÌÅ∞ Îì±Î°ù ÏôÑÎ£å', json);
      } catch (error) {
        console.error('Ìë∏Ïãú ÌÜ†ÌÅ∞ Îì±Î°ù Ïò§Î•ò:', error);
        Alert.alert(
          'Ìë∏Ïãú ÌÜ†ÌÅ∞ Îì±Î°ù Ïò§Î•ò',
          'Ìë∏Ïãú ÌÜ†ÌÅ∞ Îì±Î°ù Ï§ë Î¨∏Ï†úÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
        );
      }
    };

    registerPushToken();
  }, []);

  //ÏïåÎ¶º Î∞õÍ∏∞ Í∏∞Îä• Ï∂îÍ∞Ä
  useEffect(() => {
    const subscription = Notifications.addNotificationReceivedListener(
      (notification) => {
        console.log('ÏïåÎ¶º ÏàòÏã†:', notification);
        Alert.alert(
          'ÏïåÎ¶º ÎèÑÏ∞©',
          notification.request.content.body ?? 'ÏÉà ÏïåÎ¶ºÏù¥ ÎèÑÏ∞©ÌñàÏäµÎãàÎã§.'
        );
      }
    );

    return () => subscription.remove();
  }, []);

  // Ìè¨Ïù∏Ìä∏ Î≥¥ÎÇ¥Í∏∞
  const sendPoint = async (friend: Friend) => {
    const lastSentAt = friendPointHistories.get(friend.friend_id);
    if (lastSentAt) {
      const now = Date.now();
      if (now - lastSentAt < 60 * 1000) {
        Alert.alert('ÏïåÎ¶º', 'Ïû†Ïãú ÌõÑÏóê Îã§Ïãú Î≥¥ÎÇ¥Ïã§ Ïàò ÏûàÏäµÎãàÎã§.');
        return;
      }
    }

    try {
      const response = await fetch(
        `${SERVER_API_URL}/api/user/${friend.friend_id}/point?senderId=${MY_USER_ID}&point=5`,
        { method: 'PATCH' }
      );
      const json = await response.json();
      if (response.ok) {
        Alert.alert(
          'Ìè¨Ïù∏Ìä∏ Ï†ÑÏÜ° ÏôÑÎ£å',
          `${friend.name}ÎãòÏóêÍ≤å 5Ìè¨Ïù∏Ìä∏Î•º Î≥¥ÎÉàÏäµÎãàÎã§.`
        );

        const sentAt = json.sentAt;
        if (sentAt) {
          const sentTimestamp = new Date(sentAt).getTime();
          setFriendPointHistories((prev) =>
            new Map(prev).set(friend.friend_id, sentTimestamp)
          );
        }
      } else {
        console.error(json);
        Alert.alert(
          'Ïò§Î•ò',
          `Ìè¨Ïù∏Ìä∏ Ï†ÑÏÜ° Ïã§Ìå®: ${json.message ?? 'Ïïå Ïàò ÏóÜÏùå'}`
        );
      }
    } catch (error) {
      console.error('sendPoint error:', error);
      Alert.alert('ÎÑ§Ìä∏ÏõåÌÅ¨ Ïò§Î•ò', 'Ìè¨Ïù∏Ìä∏ Ï†ÑÏÜ°Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
    }
  };

  // ÎßåÏïΩ Ìè¨Ïù∏Ìä∏Î•º Î≥¥ÎÑÄÎã§Î©¥, ÏÑ§Ï†ïÌïú ÏãúÍ∞Ñ ÎèôÏïà Ïû†Í∏à
  useEffect(() => {
    const interval = setInterval(() => {
      setDisabledFriendTimestamps((prev) => {
        const now = Date.now();
        const updated = new Map(prev);
        for (const [friendId, sentAt] of prev.entries()) {
          // 12ÏãúÍ∞Ñ Ïû†Í∏à
          // if (now - sentAt >= 12 * 60 * 60 * 1000) {
          //   updated.delete(friendId);
          // }

          // ÌÖåÏä§Ìä∏Ïö© -> 1Î∂Ñ
          if (now - sentAt >= 60 * 1000) {
            updated.delete(friendId);
          }
        }
        return updated;
      });
    }, 1000);

    return () => clearInterval(interval);
  }, []);

  // ÏùëÏõêÌïòÍ∏∞ ÏïåÎ¶º Î≥¥ÎÇ¥Í∏∞
  const sendCheer = async (friend: Friend) => {
    try {
      const response = await fetch(
        `${SERVER_API_URL}/api/push-token/${friend.friend_id}/cheer?senderId=${MY_USER_ID}`,
        { method: 'PATCH' }
      );

      const json = await response.json();

      if (response.ok) {
        Alert.alert('ÏùëÏõê ÏôÑÎ£å', `${friend.name}ÎãòÏóêÍ≤å ÏùëÏõêÏùÑ Î≥¥ÎÉàÏäµÎãàÎã§!`);
      } else {
        console.error(json);
        Alert.alert('Ïò§Î•ò', `ÏùëÏõê Ïã§Ìå®: ${json.message ?? 'Ïïå Ïàò ÏóÜÏùå'}`);
      }
    } catch (error) {
      console.error('sendCheer error:', error);
      Alert.alert('ÎÑ§Ìä∏ÏõåÌÅ¨ Ïò§Î•ò', 'ÏùëÏõê Ï†ÑÏÜ°Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
    }
  };

  // ÏπúÍµ¨ ÏöîÏ≤≠ Ïπ¥Ïö¥Ìä∏
  const fetchPendingRequestCount = async () => {
    try {
      const response = await fetch(
        `${SERVER_API_URL}/api/friend/pending?receiverId=${MY_USER_ID}`
      );
      const json = await response.json();
      const count = json.data?.pendingCount ?? 0;
      setPendingRequests(count);
    } catch (e) {
      console.error('fetchPendingRequestCount error:', e);
    }
  };

  useEffect(() => {
    fetchFriends();
    fetchFriendRequests();
    const interval = setInterval(fetchFriendRequests, 5000);
    return () => clearInterval(interval);
  }, []);

  // ÎÇ¥ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
  useEffect(() => {
    const fetchMyInfo = async () => {
      try {
        const user = await getUserById(MY_USER_ID);
        setMyUserName(user.name);
      } catch (e) {
        console.error('ÎÇ¥ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå®', e);
      }
    };
    fetchMyInfo();
  }, []);

  // ÏπúÍµ¨ Î™©Î°ù ÌôïÏù∏ÌïòÍ∏∞
  const fetchFriendRequests = async () => {
    try {
      const response = await fetch(
        `${SERVER_API_URL}/api/friend/list/receive?senderId=${MY_USER_ID}`
      );
      const json = await response.json();
      const data = json.data ?? [];
      setPendingRequests(data.length);
      setFriendRequests(data);
    } catch (e) {
      console.error(e);
    }
  };

  // Ìè¨Ïù∏Ìä∏ Î≥¥ÎÇ∏ ÏãúÍ∞Ñ Ï°∞Ìöå
  const fetchFriends = async () => {
    try {
      setLoading(true);
      const response = await fetch(
        `${SERVER_API_URL}/api/user/${MY_USER_ID}/point-history`
      );
      if (!response.ok) throw new Error(`HTTP status ${response.status}`);
      const json = await response.json();

      const pointHistoryMap = new Map<string, number>();
      (json.data ?? []).forEach((item: any) => {
        if (item.receiverId && item.sentAt) {
          pointHistoryMap.set(
            item.receiverId.toString(),
            new Date(item.sentAt).getTime()
          );
        }
      });
      setFriendPointHistories(pointHistoryMap);

      // Í∏∞Ï°¥ ÏπúÍµ¨ Î¶¨Ïä§Ìä∏ÎèÑ Í∞ôÏù¥ fetch
      const friendListResponse = await fetch(
        `${SERVER_API_URL}/api/friend/list?senderId=${MY_USER_ID}`
      );
      if (!friendListResponse.ok)
        throw new Error(`HTTP status ${friendListResponse.status}`);
      const friendJson = await friendListResponse.json();

      const data = friendJson.data;
      if (!Array.isArray(data)) {
        throw new Error('API returned non-array data');
      }

      const processedFriends: Friend[] = data.map((item: any) => ({
        id: item.friendId?.toString() ?? '',
        friend_id: item.friendId?.toString() ?? '',
        name: item.name ?? 'Ïù¥Î¶ÑÏóÜÏùå',
        image: item.profileImageUrl
          ? { uri: item.profileImageUrl }
          : DEFAULT_AVATAR,
        level: item.level ?? null,
        grade: item.grade ?? null,
        status: item.status ?? null,
      }));

      setFriends(processedFriends);
    } catch (error) {
      console.error('fetchFriends error:', error);
      Alert.alert('Ïò§Î•ò', 'ÏπúÍµ¨ Î™©Î°ùÏùÑ Î∂àÎü¨Ïò§Îäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
    } finally {
      setLoading(false);
    }
  };

  // ÏπúÍµ¨ Î™©Î°ùÏóêÏÑú ÏÇ≠Ï†úÌïòÍ∏∞
  const handleDeleteFriend = async (friend: Friend) => {
    try {
      const response = await fetch(
        `${SERVER_API_URL}/api/friend/delete?senderId=${MY_USER_ID}&otherId=${friend.friend_id}`,
        {
          method: 'DELETE',
        }
      );

      if (response.ok) {
        Alert.alert('ÏôÑÎ£å', `${friend.name}ÎãòÏù¥ ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.`);
        setIsEditing(false);
        fetchFriends();
      } else {
        const text = await response.text();
        Alert.alert(
          'Ïò§Î•ò',
          `ÏπúÍµ¨ ÏÇ≠Ï†ú Ï§ë Î¨∏Ï†úÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.\nÏÉÅÌÉú: ${response.status}\nÎ©îÏãúÏßÄ: ${text}`
        );
      }
    } catch (error) {
      console.error('handleDeleteFriend error:', error);
      Alert.alert('Ïò§Î•ò', 'ÏπúÍµ¨ ÏÇ≠Ï†ú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
    }
  };

  // ÏπúÍµ¨ ÏöîÏ≤≠ ÏàòÎùΩÌïòÍ∏∞
  const acceptRequest = async (senderId: string) => {
    try {
      const response = await fetch(
        `${SERVER_API_URL}/api/friend/accept?senderId=${MY_USER_ID}&otherId=${senderId}`
      );
      if (response.ok) {
        Alert.alert('ÏπúÍµ¨ ÏöîÏ≤≠ ÏàòÎùΩ', 'ÏπúÍµ¨ ÏöîÏ≤≠ÏùÑ ÏàòÎùΩÌñàÏäµÎãàÎã§.');
        await fetchFriends();
        await fetchFriendRequests();
      } else {
        const text = await response.text();
        Alert.alert('Ïò§Î•ò', `ÏàòÎùΩ Ï§ë Ïò§Î•ò Î∞úÏÉù: ${text}`);
      }
    } catch (e) {
      console.error(e);
      Alert.alert('ÎÑ§Ìä∏ÏõåÌÅ¨ Ïò§Î•ò', 'ÏπúÍµ¨ ÏöîÏ≤≠ ÏàòÎùΩ Ïã§Ìå®');
    }
  };

  // ÏπúÍµ¨ ÏöîÏ≤≠ Í±∞Ï†àÌïòÍ∏∞
  const rejectRequest = async (senderId: string) => {
    try {
      const response = await fetch(
        `${SERVER_API_URL}/api/friend/reject?senderId=${MY_USER_ID}&otherId=${senderId}`
      );
      if (response.ok) {
        Alert.alert('ÏπúÍµ¨ ÏöîÏ≤≠ Í±∞Ï†à', 'ÏπúÍµ¨ ÏöîÏ≤≠ÏùÑ Í±∞Ï†àÌñàÏäµÎãàÎã§.');
        fetchFriendRequests();
      } else {
        const text = await response.text();
        Alert.alert('Ïò§Î•ò', `Í±∞Ï†à Ï§ë Ïò§Î•ò Î∞úÏÉù: ${text}`);
      }
    } catch (e) {
      console.error(e);
      Alert.alert('ÎÑ§Ìä∏ÏõåÌÅ¨ Ïò§Î•ò', 'ÏπúÍµ¨ ÏöîÏ≤≠ Í±∞Ï†à Ïã§Ìå®');
    }
  };

  return (
    // Ï†ÑÏ≤¥Ï†ÅÏù∏ ÌãÄ UI
    <View style={styles.container}>
      <View style={styles.headerContainer}>
        <TouchableOpacity onPress={() => navigation.goBack()}>
          <Text style={styles.backButton}>‚Üê</Text>
        </TouchableOpacity>
        <View>
          <Text style={styles.title}>Ïö©Ïù∏Ïãú Ï≤òÏù∏Íµ¨</Text>
          <Text style={styles.subTitle}>Îü¨ÎÑà Í∑∏ÎùºÏö¥Îìú</Text>
        </View>
        <TouchableOpacity
          style={styles.bellButton}
          onPress={() => setShowRequests(!showRequests)}
        >
          <Ionicons name="notifications-outline" size={28} color="#333" />
          {pendingRequests > 0 && (
            <View style={styles.badge}>
              <Text style={styles.badgeText}>
                {pendingRequests > 99 ? '99+' : pendingRequests}
              </Text>
            </View>
          )}
        </TouchableOpacity>
        <TouchableOpacity
          style={styles.iconButton}
          onPress={() => router.push('/SocialAdd')}
        >
          <Image
            source={require('@/assets/images/profile-icon.png')}
            style={styles.iconImage}
          />
        </TouchableOpacity>
        <TouchableOpacity
          onPress={() => setIsEditing(!isEditing)}
          style={{ marginLeft: 12 }}
        >
          <Text style={{ color: '#32CD32', fontWeight: 'bold' }}>
            {isEditing ? 'ÏôÑÎ£å' : 'Ìé∏Ïßë'}
          </Text>
        </TouchableOpacity>
      </View>

      {/* ÏπúÍµ¨ ÏàòÎùΩ / Í±∞Ï†à Ï∞Ω */}
      {showRequests ? (
        <View style={styles.friendRequestContainer}>
          <Text style={styles.friendRequestTitle}>
            ÏπúÍµ¨ ÏöîÏ≤≠ ({friendRequests.length})
          </Text>
          {friendRequests.length === 0 ? (
            <Text style={styles.noRequestsText}>
              ÏÉàÎ°úÏö¥ ÏπúÍµ¨ ÏöîÏ≤≠Ïù¥ ÏóÜÏäµÎãàÎã§.
            </Text>
          ) : (
            <ScrollView
              style={styles.friendRequestList}
              contentContainerStyle={{ paddingVertical: 8 }}
              nestedScrollEnabled
            >
              {friendRequests.map((req, index) => (
                <View
                  key={`${req.id}_${index}`}
                  style={styles.friendRequestItem}
                >
                  <Text style={styles.requestName}>
                    {req.name || 'Ïïå Ïàò ÏóÜÏùå'}
                  </Text>
                  <View style={styles.requestButtons}>
                    <TouchableOpacity
                      style={[styles.requestButton, styles.acceptButton]}
                      onPress={() => acceptRequest(req.friendId.toString())}
                    >
                      <Text style={styles.requestButtonText}>ÏàòÎùΩ</Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                      style={[styles.requestButton, styles.rejectButton]}
                      onPress={() => rejectRequest(req.friendId.toString())}
                    >
                      <Text style={styles.requestButtonText}>Í±∞Ï†à</Text>
                    </TouchableOpacity>
                  </View>
                </View>
              ))}
            </ScrollView>
          )}
          <TouchableOpacity
            style={styles.closeButton}
            onPress={() => setShowRequests(false)}
          >
            <Text style={styles.closeButtonText}>Îã´Í∏∞</Text>
          </TouchableOpacity>
        </View>
      ) : (
        // ÏπúÍµ¨ Î™©Î°ù ÌéòÏù¥ÏßÄ => ÏπúÍµ¨ Ï†ïÎ≥¥, ÏùëÏõêÌïòÍ∏∞ and Ìè¨Ïù∏Ìä∏ Î≥¥ÎÇ¥Í∏∞ Î≤ÑÌäº
        <View style={styles.mapContainer}>
          {loading ? (
            <ActivityIndicator size="large" color="#32CD32" />
          ) : friends.length === 0 ? (
            <Text style={styles.noFriendsText}>Îì±Î°ùÎêú ÏπúÍµ¨Í∞Ä ÏóÜÏäµÎãàÎã§.</Text>
          ) : (
            <ScrollView contentContainerStyle={{ paddingVertical: 16 }}>
              {friends.map((friend, index) => (
                <View key={`${friend.id}_${index}`} style={styles.friendItem}>
                  <Image source={friend.image} style={styles.friendImage} />
                  <View style={styles.friendNameContainer}>
                    <Text style={styles.friendName}>{friend.name}</Text>
                    {friend.level && friend.grade && (
                      <Text style={styles.friendLevelGrade}>
                        Lv.{friend.level} | {friend.grade}
                      </Text>
                    )}
                  </View>

                  {/* ÏùëÏõêÌïòÍ∏∞ / Ìè¨Ïù∏Ìä∏ Î≥¥ÎÇ¥Í∏∞ Î≤ÑÌäº */}
                  {!isEditing && (
                    <View style={styles.actionButtonsContainer}>
                      <TouchableOpacity
                        onPress={() => sendCheer(friend)}
                        style={styles.actionButton}
                      >
                        <Ionicons
                          name="heart-outline"
                          size={20}
                          color="#FF4081"
                        />
                        <Text style={styles.actionButtonText}>ÏùëÏõê</Text>
                      </TouchableOpacity>
                      <TouchableOpacity
                        disabled={(() => {
                          const lastSentAt = friendPointHistories.get(
                            friend.friend_id
                          );
                          if (!lastSentAt) return false;

                          // ÌÖåÏä§Ìä∏Ïö© 1Î∂Ñ
                          return Date.now() - lastSentAt < 60 * 1000;

                          // Í∏∞Î≥∏ 12ÏãúÍ∞Ñ
                          //return Date.now() - lastSentAt < 43200 * 1000;
                        })()}
                        onPress={() => sendPoint(friend)}
                        style={[
                          styles.actionButton,
                          (() => {
                            const lastSentAt = friendPointHistories.get(
                              friend.friend_id
                            );
                            if (
                              lastSentAt &&
                              Date.now() - lastSentAt < 60 * 1000
                              //Date.now() - lastSentAt < 43200 * 1000
                            ) {
                              return { opacity: 0.5 };
                            }
                            return {};
                          })(),
                        ]}
                      >
                        <Ionicons
                          name="cash-outline"
                          size={20}
                          color="#FFD700"
                        />
                        <Text style={styles.actionButtonText}>‚Üí</Text>
                      </TouchableOpacity>
                    </View>
                  )}

                  {/* ÏπúÍµ¨ ÏöîÏ≤≠ ÏàòÎùΩ Î≤ÑÌäº */}
                  {isEditing && (
                    <TouchableOpacity
                      onPress={() =>
                        Alert.alert(
                          'ÏπúÍµ¨ ÏÇ≠Ï†ú',
                          `${friend.name}ÎãòÍ≥º ÏπúÍµ¨Î•º ÎÅäÏúºÏãúÍ≤†ÏäµÎãàÍπå?`,
                          [
                            { text: 'Ï∑®ÏÜå', style: 'cancel' },
                            {
                              text: 'ÌôïÏù∏',
                              style: 'destructive',
                              onPress: () => handleDeleteFriend(friend),
                            },
                          ]
                        )
                      }
                      style={styles.deleteButton}
                    >
                      <Ionicons name="trash-outline" size={20} color="red" />
                    </TouchableOpacity>
                  )}
                </View>
              ))}
            </ScrollView>
          )}
        </View>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    paddingTop: 20,
    paddingHorizontal: 20,
  },
  headerContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginBottom: 20,
  },
  subTitle: { fontSize: 12 },
  title: { fontSize: 20, fontWeight: 'bold', color: '#222' },
  backButton: { fontSize: 24, color: '#333', marginRight: 12 },
  bellButton: { position: 'relative', padding: 5 },
  badge: {
    position: 'absolute',
    top: -4,
    right: -5,
    minWidth: 18,
    height: 18,
    borderRadius: 9,
    backgroundColor: '#FF4C4C',
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 4,
    zIndex: 10,
  },
  badgeText: { color: 'white', fontSize: 11, fontWeight: 'bold' },
  friendRequestContainer: {
    backgroundColor: '#f9f9f9',
    borderRadius: 8,
    padding: 12,
    marginBottom: 16,
    maxHeight: 180,
    borderWidth: 1,
    borderColor: '#ddd',
  },
  friendRequestTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 8,
    color: '#333',
  },
  noRequestsText: { textAlign: 'center', color: '#777' },
  friendRequestList: {},
  friendRequestItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 6,
    borderBottomWidth: 1,
    borderColor: '#ddd',
  },
  requestName: { fontSize: 14, color: '#222' },
  requestButtons: { flexDirection: 'row' },
  requestButton: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 4,
    marginLeft: 8,
  },
  acceptButton: { backgroundColor: '#32CD32' },
  rejectButton: { backgroundColor: '#FF4C4C' },
  requestButtonText: { color: '#fff', fontWeight: 'bold' },
  closeButton: {
    marginTop: 10,
    backgroundColor: '#32CD32',
    borderRadius: 6,
    paddingVertical: 8,
    alignItems: 'center',
  },
  closeButtonText: { color: '#fff', fontWeight: 'bold' },
  mapContainer: { flex: 1 },
  noFriendsText: { textAlign: 'center', marginTop: 50, color: '#555' },
  friendItem: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 16,
    borderWidth: 1,
    borderColor: '#333',
    borderRadius: 8,
    padding: 8,
    backgroundColor: '#fff',
  },
  friendImage: {
    width: 60,
    height: 60,
    borderRadius: 30,
    marginRight: 12,
    borderWidth: 2,
    borderColor: '#4caf50',
  },
  friendNameContainer: { flexDirection: 'column', justifyContent: 'center' },
  friendName: { fontSize: 16, fontWeight: '600', color: '#333' },
  friendLevelGrade: { fontSize: 12, color: '#555', marginTop: 2 },
  deleteButton: {
    marginLeft: 'auto',
    backgroundColor: '#f0f0f0',
    borderRadius: 12,
    padding: 4,
    elevation: 3,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 1.41,
  },
  actionButtonsContainer: {
    flexDirection: 'row',
    marginLeft: 'auto',
  },

  actionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f0f0f0',
    borderRadius: 20,
    paddingVertical: 6,
    paddingHorizontal: 10,
    marginLeft: 8,
  },

  actionButtonText: {
    marginLeft: 4,
    fontSize: 12,
    color: '#333',
    fontWeight: '500',
  },
  iconButton: {
    marginLeft: 8,
    padding: 4,
  },
  iconImage: {
    width: 24,
    height: 24,
    resizeMode: 'contain',
  },
});
